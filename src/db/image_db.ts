// create table public."Images" (
//     id bigint generated by default as identity not null,
//     created_at timestamp with time zone not null default now(),
//     path text not null,
//     container_id bigint not null,
//     ordering_index bigint not null,
//     clerk_user_id text not null default (auth.jwt () ->> 'sub'::text),
//     constraint Images_pkey primary key (id),
//     constraint Images_container_id_fkey foreign KEY (container_id) references "Containers" (id) on delete CASCADE
// ) TABLESPACE pg_default;

import { useEffect, useState, useCallback } from "react"
import { useUser } from "@clerk/clerk-react"
import { useSupabaseClient, type Status } from "./supabase"
import type { ContentImage } from "@/components/types"

type DatabaseImage = {
    id: number
    path: string
    container_id: number
    ordering_index: number
    created_at: string
    clerk_user_id: string
}

const STORAGE_BUCKET = "container_images"

function mapDatabaseImageToContentImage(dbImage: DatabaseImage, publicUrl: string): ContentImage {
    return {
        id: dbImage.id.toString(),
        url: publicUrl,
    }
}

export function useReadImages(containerId: string) {
    const supabase = useSupabaseClient()
    const { user } = useUser()
    const [images, setImages] = useState<ContentImage[]>([])
    const [status, setStatus] = useState<Status>("idle")
    const [error, setError] = useState<Error | null>(null)

    useEffect(() => {
        if (!user || !supabase) {
            setStatus("idle")
            return
        }

        async function fetchImages() {
            if (!supabase) return
            try {
                setStatus("loading")
                setError(null)

                const containerIdNum = parseInt(containerId, 10)
                if (isNaN(containerIdNum)) {
                    throw new Error("Invalid container ID")
                }

                const { data, error: fetchError } = await supabase
                    .from("Images")
                    .select("*")
                    .eq("container_id", containerIdNum)
                    .order("ordering_index", { ascending: true })

                if (fetchError) {
                    throw fetchError
                }

                if (!data || data.length === 0) {
                    setImages([])
                    setStatus("success")
                    return
                }

                // Get signed URLs for all file paths
                const filePaths = data.map((dbImage) => dbImage.path)
                const { data: urlsData, error: urlError } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrls(filePaths, 3600) // 3600 seconds = 1 hour

                if (urlError) {
                    throw urlError
                }

                // Map images with signed URLs
                const mappedImages = data.map((dbImage, index) => {
                    const signedUrl = urlsData?.[index]?.signedUrl || ""
                    return mapDatabaseImageToContentImage(dbImage, signedUrl)
                })

                setImages(mappedImages)
                setStatus("success")
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to fetch images")
                setError(error)
                setStatus("error")
            }
        }

        fetchImages()
    }, [supabase, user, containerId])

    return { status, error, images }
}

export function useWriteImages() {
    const supabase = useSupabaseClient()
    const { user } = useUser()

    const upsertImage = useCallback(
        async (
            file: File,
            containerId: string,
            orderingIndex: number,
            existingImageId?: string
        ): Promise<{ status: Status; error: Error | null; image: ContentImage | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                    image: null,
                }
            }

            if (!user) {
                return {
                    status: "error",
                    error: new Error("User not authenticated"),
                    image: null,
                }
            }

            try {
                const containerIdNum = parseInt(containerId, 10)
                if (isNaN(containerIdNum)) {
                    throw new Error("Invalid container ID")
                }

                // Get user ID from Clerk (matches auth.jwt() ->> 'sub'::text)
                const userId = user.id

                // Get file extension
                const lastDotIndex = file.name.lastIndexOf(".")
                const fileExtension = lastDotIndex > 0 ? file.name.substring(lastDotIndex + 1) : "jpg"
                const baseFileName = lastDotIndex > 0 ? file.name.substring(0, lastDotIndex) : file.name

                // Generate unique file path: userId/containerId/timestamp_filename.extension
                const timestamp = Date.now()
                const sanitizedFileName = baseFileName.replace(/[^a-zA-Z0-9.-]/g, "_")
                const filePath = `${userId}/${containerId}/${timestamp}_${sanitizedFileName}.${fileExtension}`

                // Upload file to storage
                const { error: uploadError } = await supabase.storage.from(STORAGE_BUCKET).upload(filePath, file, {
                    upsert: false,
                })

                if (uploadError) {
                    throw uploadError
                }

                const storagePath = filePath

                // Get signed URL for the uploaded file
                const { data: signedUrlData, error: signedUrlError } = await supabase.storage
                    .from(STORAGE_BUCKET)
                    .createSignedUrl(filePath, 3600) // 3600 seconds = 1 hour

                if (signedUrlError) {
                    // If signed URL creation fails, delete the uploaded file
                    await supabase.storage.from(STORAGE_BUCKET).remove([storagePath])
                    throw signedUrlError
                }

                const signedUrl = signedUrlData?.signedUrl || ""

                const isUpdate = existingImageId && !isNaN(parseInt(existingImageId, 10))

                if (isUpdate) {
                    const imageId = parseInt(existingImageId!, 10)

                    // Get old image path to delete it
                    const { data: oldImageData } = await supabase.from("Images").select("path").eq("id", imageId).single()

                    // Update database with new path
                    const { data, error: updateError } = await supabase
                        .from("Images")
                        .update({
                            path: storagePath,
                            ordering_index: orderingIndex,
                        })
                        .eq("id", imageId)
                        .select()
                        .single()

                    if (updateError) {
                        // If update fails, delete the uploaded file
                        await supabase.storage.from(STORAGE_BUCKET).remove([storagePath])
                        throw updateError
                    }

                    // Delete old file from storage if it exists
                    if (oldImageData && oldImageData.path && oldImageData.path !== storagePath) {
                        await supabase.storage.from(STORAGE_BUCKET).remove([oldImageData.path])
                    }

                    return {
                        status: "success",
                        error: null,
                        image: data ? mapDatabaseImageToContentImage(data, signedUrl) : null,
                    }
                } else {
                    // Insert new image record
                    const { data, error: insertError } = await supabase
                        .from("Images")
                        .insert({
                            path: storagePath,
                            container_id: containerIdNum,
                            ordering_index: orderingIndex,
                        })
                        .select()
                        .single()

                    if (insertError) {
                        // If insert fails, delete the uploaded file
                        await supabase.storage.from(STORAGE_BUCKET).remove([storagePath])
                        throw insertError
                    }

                    return {
                        status: "success",
                        error: null,
                        image: data ? mapDatabaseImageToContentImage(data, signedUrl) : null,
                    }
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to upsert image")
                return {
                    status: "error",
                    error,
                    image: null,
                }
            }
        },
        [supabase, user]
    )

    const deleteImage = useCallback(
        async (imageId: string): Promise<{ status: Status; error: Error | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                }
            }

            try {
                const id = parseInt(imageId, 10)
                if (isNaN(id)) {
                    throw new Error("Invalid image ID")
                }

                // Delete from database only - keep file in storage
                const { error: deleteError } = await supabase.from("Images").delete().eq("id", id)

                if (deleteError) {
                    throw deleteError
                }

                return {
                    status: "success",
                    error: null,
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to delete image")
                return {
                    status: "error",
                    error,
                }
            }
        },
        [supabase]
    )

    const uploadImage = useCallback(
        async (
            file: File,
            containerId: string,
            orderingIndex: number
        ): Promise<{ status: Status; error: Error | null; image: ContentImage | null }> => {
            return upsertImage(file, containerId, orderingIndex)
        },
        [upsertImage]
    )

    const updateImageOrder = useCallback(
        async (imageId: string, orderingIndex: number): Promise<{ status: Status; error: Error | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                }
            }

            try {
                const id = parseInt(imageId, 10)
                if (isNaN(id)) {
                    throw new Error("Invalid image ID")
                }

                const { error: updateError } = await supabase.from("Images").update({ ordering_index: orderingIndex }).eq("id", id)

                if (updateError) {
                    throw updateError
                }

                return {
                    status: "success",
                    error: null,
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to update image order")
                return {
                    status: "error",
                    error,
                }
            }
        },
        [supabase]
    )

    return {
        upsertImage,
        uploadImage,
        deleteImage,
        updateImageOrder,
    }
}
