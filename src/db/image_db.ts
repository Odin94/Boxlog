// create table public."Images" (
//     id bigint generated by default as identity not null,
//     created_at timestamp with time zone not null default now(),
//     path text not null,
//     container_id bigint not null,
//     ordering_index bigint not null,
//     clerk_user_id text not null default (auth.jwt () ->> 'sub'::text),
//     constraint Images_pkey primary key (id),
//     constraint Images_container_id_fkey foreign KEY (container_id) references "Containers" (id) on delete CASCADE
// ) TABLESPACE pg_default;

import { useEffect, useState, useCallback } from "react"
import { useUser } from "@clerk/clerk-react"
import { useSupabaseClient, type Status } from "./supabase"
import type { ContentImage } from "@/components/types"

type DatabaseImage = {
    id: number
    path: string
    container_id: number
    ordering_index: number
    created_at: string
    clerk_user_id: string
}

function mapDatabaseImageToContentImage(dbImage: DatabaseImage): ContentImage {
    return {
        id: dbImage.id.toString(),
        url: dbImage.path,
    }
}

export function useReadImages(containerId: string) {
    const supabase = useSupabaseClient()
    const { user } = useUser()
    const [images, setImages] = useState<ContentImage[]>([])
    const [status, setStatus] = useState<Status>("idle")
    const [error, setError] = useState<Error | null>(null)

    useEffect(() => {
        if (!user || !supabase) {
            setStatus("idle")
            return
        }

        async function fetchImages() {
            if (!supabase) return
            try {
                setStatus("loading")
                setError(null)

                const containerIdNum = parseInt(containerId, 10)
                if (isNaN(containerIdNum)) {
                    throw new Error("Invalid container ID")
                }

                const { data, error: fetchError } = await supabase
                    .from("Images")
                    .select("*")
                    .eq("container_id", containerIdNum)
                    .order("ordering_index", { ascending: true })

                if (fetchError) {
                    throw fetchError
                }

                const mappedImages = (data || []).map(mapDatabaseImageToContentImage)
                setImages(mappedImages)
                setStatus("success")
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to fetch images")
                setError(error)
                setStatus("error")
            }
        }

        fetchImages()
    }, [supabase, user, containerId])

    return { status, error, images }
}

export function useWriteImages() {
    const supabase = useSupabaseClient()

    const upsertImage = useCallback(
        async (
            image: ContentImage,
            containerId: string,
            orderingIndex: number
        ): Promise<{ status: Status; error: Error | null; image: ContentImage | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                    image: null,
                }
            }

            try {
                const imageId = image.id ? parseInt(image.id, 10) : null
                const containerIdNum = parseInt(containerId, 10)
                if (isNaN(containerIdNum)) {
                    throw new Error("Invalid container ID")
                }

                const isUpdate = imageId && !isNaN(imageId) && imageId < 2147483647

                if (isUpdate) {
                    const { data, error: updateError } = await supabase
                        .from("Images")
                        .update({
                            path: image.url,
                            ordering_index: orderingIndex,
                        })
                        .eq("id", imageId)
                        .select()
                        .single()

                    if (updateError) {
                        throw updateError
                    }

                    return {
                        status: "success",
                        error: null,
                        image: data ? mapDatabaseImageToContentImage(data) : null,
                    }
                } else {
                    const { data, error: insertError } = await supabase
                        .from("Images")
                        .insert({
                            path: image.url,
                            container_id: containerIdNum,
                            ordering_index: orderingIndex,
                        })
                        .select()
                        .single()

                    if (insertError) {
                        throw insertError
                    }

                    return {
                        status: "success",
                        error: null,
                        image: data ? mapDatabaseImageToContentImage(data) : null,
                    }
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to upsert image")
                return {
                    status: "error",
                    error,
                    image: null,
                }
            }
        },
        [supabase]
    )

    const deleteImage = useCallback(
        async (imageId: string): Promise<{ status: Status; error: Error | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                }
            }

            try {
                const id = parseInt(imageId, 10)
                if (isNaN(id)) {
                    throw new Error("Invalid image ID")
                }

                const { error: deleteError } = await supabase.from("Images").delete().eq("id", id)

                if (deleteError) {
                    throw deleteError
                }

                return {
                    status: "success",
                    error: null,
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to delete image")
                return {
                    status: "error",
                    error,
                }
            }
        },
        [supabase]
    )

    return {
        upsertImage,
        deleteImage,
    }
}
