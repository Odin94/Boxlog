// create table public."Containers" (
//   id bigint generated by default as identity not null,
//   created_at timestamp with time zone not null default now(),
//   name text not null,
//   title_image_path text null,
//   category_id bigint null,
//   clerk_user_id text not null default (auth.jwt () ->> 'sub'::text),
//   constraint Containers_pkey primary key (id),
//   constraint Containers_category_id_fkey foreign KEY (category_id) references "Categories" (id) on delete set null
// ) TABLESPACE pg_default;

import { useEffect, useState, useCallback } from "react"
import { useUser } from "@clerk/clerk-react"
import { useSupabaseClient, type Status } from "./supabase"
import type { Container } from "@/components/types"

type DatabaseContainer = {
    id: number
    name: string
    title_image_path: string | null
    category_id: number | null
    created_at: string
    clerk_user_id: string
}

function mapDatabaseContainerToContainer(dbContainer: DatabaseContainer): Container {
    return {
        id: dbContainer.id.toString(),
        name: dbContainer.name,
        coverImage: dbContainer.title_image_path || undefined,
        categoryId: dbContainer.category_id?.toString(),
        contentImages: [],
    }
}

export function useReadContainers() {
    const supabase = useSupabaseClient()
    const { user } = useUser()
    const [containers, setContainers] = useState<Container[]>([])
    const [status, setStatus] = useState<Status>("idle")
    const [error, setError] = useState<Error | null>(null)

    useEffect(() => {
        if (!user || !supabase) {
            setStatus("idle")
            return
        }

        async function fetchContainers() {
            if (!supabase) return
            try {
                setStatus("loading")
                setError(null)

                const { data: containersData, error: fetchError } = await supabase.from("Containers").select("*")

                if (fetchError) {
                    throw fetchError
                }

                // Fetch images for all containers
                const containerIds = (containersData || []).map((c) => c.id)
                const { data: imagesData, error: imagesError } = await supabase
                    .from("Images")
                    .select("*")
                    .in("container_id", containerIds)
                    .order("ordering_index", { ascending: true })

                if (imagesError) {
                    throw imagesError
                }

                // Group images by container_id
                type DatabaseImage = {
                    id: number
                    path: string
                    container_id: number
                    ordering_index: number
                    description: string | null
                    created_at: string
                    clerk_user_id: string
                }
                const imagesByContainer = new Map<number, DatabaseImage[]>()
                ;(imagesData || []).forEach((img: DatabaseImage) => {
                    const existing = imagesByContainer.get(img.container_id) || []
                    existing.push(img)
                    imagesByContainer.set(img.container_id, existing)
                })

                // Get signed URLs for all images
                const allImagePaths: string[] = []
                
                containersData?.forEach((dbContainer) => {
                    const images = imagesByContainer.get(dbContainer.id) || []
                    images.forEach((img) => {
                        allImagePaths.push(img.path)
                    })
                })

                // Batch create signed URLs for all images
                let signedUrlsMap = new Map<string, string>()
                if (allImagePaths.length > 0) {
                    const { data: urlsData, error: urlError } = await supabase.storage
                        .from("container_images")
                        .createSignedUrls(allImagePaths, 3600) // 3600 seconds = 1 hour

                    if (urlError) {
                        throw urlError
                    }

                    // Map paths to signed URLs
                    allImagePaths.forEach((path, index) => {
                        const signedUrl = urlsData?.[index]?.signedUrl || ""
                        signedUrlsMap.set(path, signedUrl)
                    })
                }

                // Map containers with their images using signed URLs
                const mappedContainers = (containersData || []).map((dbContainer) => {
                    const container = mapDatabaseContainerToContainer(dbContainer)
                    const images = imagesByContainer.get(dbContainer.id) || []
                    container.contentImages = images.map((img) => {
                        const signedUrl = signedUrlsMap.get(img.path) || ""
                        return {
                            id: img.id.toString(),
                            url: signedUrl,
                            description: img.description || undefined,
                        }
                    })
                    return container
                })

                setContainers(mappedContainers)
                setStatus("success")
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to fetch containers")
                setError(error)
                setStatus("error")
            }
        }

        fetchContainers()
    }, [supabase, user])

    return { status, error, containers }
}

export function useWriteContainers() {
    const supabase = useSupabaseClient()

    const upsertContainer = useCallback(
        async (container: Container): Promise<{ status: Status; error: Error | null; container: Container | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                    container: null,
                }
            }

            try {
                const containerId = container.id ? parseInt(container.id, 10) : null
                const categoryId = container.categoryId ? parseInt(container.categoryId, 10) : null
                const isUpdate = containerId && !isNaN(containerId) && containerId < 2147483647

                if (isUpdate) {
                    const { data, error: updateError } = await supabase
                        .from("Containers")
                        .update({
                            name: container.name,
                            title_image_path: container.coverImage || null,
                            category_id: categoryId,
                        })
                        .eq("id", containerId)
                        .select()
                        .single()

                    if (updateError) {
                        throw updateError
                    }

                    return {
                        status: "success",
                        error: null,
                        container: data ? mapDatabaseContainerToContainer(data) : null,
                    }
                } else {
                    const { data, error: insertError } = await supabase
                        .from("Containers")
                        .insert({
                            name: container.name,
                            title_image_path: container.coverImage || null,
                            category_id: categoryId,
                        })
                        .select()
                        .single()

                    if (insertError) {
                        throw insertError
                    }

                    return {
                        status: "success",
                        error: null,
                        container: data ? mapDatabaseContainerToContainer(data) : null,
                    }
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to upsert container")
                return {
                    status: "error",
                    error,
                    container: null,
                }
            }
        },
        [supabase]
    )

    const deleteContainer = useCallback(
        async (containerId: string): Promise<{ status: Status; error: Error | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                }
            }

            try {
                const id = parseInt(containerId, 10)
                if (isNaN(id)) {
                    throw new Error("Invalid container ID")
                }

                const { error: deleteError } = await supabase.from("Containers").delete().eq("id", id)

                if (deleteError) {
                    throw deleteError
                }

                return {
                    status: "success",
                    error: null,
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to delete container")
                return {
                    status: "error",
                    error,
                }
            }
        },
        [supabase]
    )

    return {
        upsertContainer,
        deleteContainer,
    }
}
