// create table public."Containers" (
//   id bigint generated by default as identity not null,
//   created_at timestamp with time zone not null default now(),
//   name text not null,
//   title_image_path text null,
//   category_id bigint null,
//   clerk_user_id text not null default (auth.jwt () ->> 'sub'::text),
//   constraint Containers_pkey primary key (id),
//   constraint Containers_category_id_fkey foreign KEY (category_id) references "Categories" (id) on delete set null
// ) TABLESPACE pg_default;

import { useEffect, useState, useCallback } from "react"
import { useUser } from "@clerk/clerk-react"
import { useSupabaseClient, type Status } from "./supabase"
import type { Container } from "@/components/types"

type DatabaseContainer = {
    id: number
    name: string
    title_image_path: string | null
    category_id: number | null
    created_at: string
    clerk_user_id: string
}

function mapDatabaseContainerToContainer(dbContainer: DatabaseContainer): Container {
    return {
        id: dbContainer.id.toString(),
        name: dbContainer.name,
        coverImage: dbContainer.title_image_path || undefined,
        categoryId: dbContainer.category_id?.toString(),
        // TODOdin: Load content images from the database
        contentImages: [],
    }
}

export function useReadContainers() {
    const supabase = useSupabaseClient()
    const { user } = useUser()
    const [containers, setContainers] = useState<Container[]>([])
    const [status, setStatus] = useState<Status>("idle")
    const [error, setError] = useState<Error | null>(null)

    useEffect(() => {
        if (!user || !supabase) {
            setStatus("idle")
            return
        }

        async function fetchContainers() {
            if (!supabase) return
            try {
                setStatus("loading")
                setError(null)

                const { data, error: fetchError } = await supabase.from("Containers").select("*")

                if (fetchError) {
                    throw fetchError
                }

                const mappedContainers = (data || []).map(mapDatabaseContainerToContainer)
                setContainers(mappedContainers)
                setStatus("success")
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to fetch containers")
                setError(error)
                setStatus("error")
            }
        }

        fetchContainers()
    }, [supabase, user])

    return { status, error, containers }
}

export function useWriteContainers() {
    const supabase = useSupabaseClient()

    const upsertContainer = useCallback(
        async (container: Container): Promise<{ status: Status; error: Error | null; container: Container | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                    container: null,
                }
            }

            try {
                const containerId = container.id ? parseInt(container.id, 10) : null
                const categoryId = container.categoryId ? parseInt(container.categoryId, 10) : null
                const isUpdate = containerId && !isNaN(containerId) && containerId < 2147483647

                if (isUpdate) {
                    const { data, error: updateError } = await supabase
                        .from("Containers")
                        .update({
                            name: container.name,
                            title_image_path: container.coverImage || null,
                            category_id: categoryId,
                        })
                        .eq("id", containerId)
                        .select()
                        .single()

                    if (updateError) {
                        throw updateError
                    }

                    return {
                        status: "success",
                        error: null,
                        container: data ? mapDatabaseContainerToContainer(data) : null,
                    }
                } else {
                    const { data, error: insertError } = await supabase
                        .from("Containers")
                        .insert({
                            name: container.name,
                            title_image_path: container.coverImage || null,
                            category_id: categoryId,
                        })
                        .select()
                        .single()

                    if (insertError) {
                        throw insertError
                    }

                    return {
                        status: "success",
                        error: null,
                        container: data ? mapDatabaseContainerToContainer(data) : null,
                    }
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to upsert container")
                return {
                    status: "error",
                    error,
                    container: null,
                }
            }
        },
        [supabase]
    )

    const deleteContainer = useCallback(
        async (containerId: string): Promise<{ status: Status; error: Error | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                }
            }

            try {
                const id = parseInt(containerId, 10)
                if (isNaN(id)) {
                    throw new Error("Invalid container ID")
                }

                const { error: deleteError } = await supabase.from("Containers").delete().eq("id", id)

                if (deleteError) {
                    throw deleteError
                }

                return {
                    status: "success",
                    error: null,
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to delete container")
                return {
                    status: "error",
                    error,
                }
            }
        },
        [supabase]
    )

    return {
        upsertContainer,
        deleteContainer,
    }
}
