// create table public."Categories" (
//   id bigint generated by default as identity not null,
//   created_at timestamp with time zone not null default now(),
//   name text not null,
//   index bigint not null,
//   clerk_user_id text not null default (auth.jwt () ->> 'sub'::text),
//   constraint Categories_pkey primary key (id),
// ) TABLESPACE pg_default;

import { useEffect, useState, useCallback } from "react"
import { useUser } from "@clerk/clerk-react"
import { useSupabaseClient, type Status } from "./supabase"
import type { Category } from "@/components/types"

type DatabaseCategory = {
    id: number
    name: string
    index: number
    created_at: string
    clerk_user_id: string
}

function mapDatabaseCategoryToCategory(dbCategory: DatabaseCategory): Category {
    return {
        id: dbCategory.id.toString(),
        name: dbCategory.name,
        order: dbCategory.index,
    }
}

export function useReadCategories() {
    const supabase = useSupabaseClient()
    const { user } = useUser()
    const [categories, setCategories] = useState<Category[]>([])
    const [status, setStatus] = useState<Status>("idle")
    const [error, setError] = useState<Error | null>(null)

    useEffect(() => {
        if (!user || !supabase) {
            setStatus("idle")
            return
        }

        async function fetchCategories() {
            if (!supabase) return
            try {
                setStatus("loading")
                setError(null)

                const { data, error: fetchError } = await supabase.from("Categories").select("*").order("index", { ascending: true })

                if (fetchError) {
                    throw fetchError
                }

                const mappedCategories = (data || []).map(mapDatabaseCategoryToCategory)
                setCategories(mappedCategories)
                setStatus("success")
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to fetch categories")
                setError(error)
                setStatus("error")
            }
        }

        fetchCategories()
    }, [supabase, user])

    return { status, error, categories }
}

export function useWriteCategories() {
    const supabase = useSupabaseClient()

    const upsertCategory = useCallback(
        async (category: Category): Promise<{ status: Status; error: Error | null; category: Category | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                    category: null,
                }
            }

            try {
                const categoryId = category.id ? parseInt(category.id, 10) : null
                const index = category.order ?? 0
                const isUpdate = categoryId && !isNaN(categoryId) && categoryId < 2147483647

                if (isUpdate) {
                    const { data, error: updateError } = await supabase
                        .from("Categories")
                        .update({ name: category.name, index })
                        .eq("id", categoryId)
                        .select()
                        .single()

                    if (updateError) {
                        throw updateError
                    }

                    return {
                        status: "success",
                        error: null,
                        category: data ? mapDatabaseCategoryToCategory(data) : null,
                    }
                } else {
                    const { data, error: insertError } = await supabase
                        .from("Categories")
                        .insert({ name: category.name, index })
                        .select()
                        .single()

                    if (insertError) {
                        throw insertError
                    }

                    return {
                        status: "success",
                        error: null,
                        category: data ? mapDatabaseCategoryToCategory(data) : null,
                    }
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to upsert category")
                return {
                    status: "error",
                    error,
                    category: null,
                }
            }
        },
        [supabase]
    )

    const deleteCategory = useCallback(
        async (categoryId: string): Promise<{ status: Status; error: Error | null }> => {
            if (!supabase) {
                return {
                    status: "error",
                    error: new Error("Supabase client not available"),
                }
            }

            try {
                const id = parseInt(categoryId, 10)
                if (isNaN(id)) {
                    throw new Error("Invalid category ID")
                }

                const { error: deleteError } = await supabase.from("Categories").delete().eq("id", id)

                if (deleteError) {
                    throw deleteError
                }

                return {
                    status: "success",
                    error: null,
                }
            } catch (err) {
                const error = err instanceof Error ? err : new Error("Failed to delete category")
                return {
                    status: "error",
                    error,
                }
            }
        },
        [supabase]
    )

    return {
        upsertCategory,
        deleteCategory,
    }
}
